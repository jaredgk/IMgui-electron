{
  "name": "electron-window-manager",
  "version": "1.0.1",
  "description": "A NodeJs module that handles window management for Electron (Atom Shell, previously)",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/azain/electron-window-manager.git"
  },
  "keywords": [
    "electron",
    "atom shell",
    "window",
    "browser",
    "desktop"
  ],
  "author": {
    "name": "Ahmed Zain",
    "email": "tamkeenlms@gmail.com"
  },
  "license": "MIT",
  "dependencies": {
    "electron-localshortcut": "^0.6.0",
    "underscore": "^1.8.3",
    "watchjs": "git+https://github.com/melanke/Watch.JS.git"
  },
  "readme": "# What it is\r\n\r\n> A NodeJs module for [Electron](http://electron.atom.io/) (Atom Shell, previously) that will help you create, control, manage and connect your application windows very easily.\r\n\r\nMost of the applications created using Electron are one-window applications, I am not sure why, but that's the case, maybe because we - as web developers - are used to building inside one window (that of the browser). But, if you are to build a multi-window Electron application then you may need to have a look at this module.\r\n\r\n\r\n* [Features](#features)\r\n* [Installation](#installation)\r\n* [How it works](#how-it-works)\r\n* [Class: WindowManager](#class-windowmanager)\r\n    * [Method: createNew](#createnew-name-title-url-setuptemplate-setup-showdevtools-)\r\n    * [.templates](#class-windowmanagertemplates)\r\n    * [.layouts](#class-windowmanagerlayouts)\r\n    * [.sharedDate](#class-windowmanagershareddata)\r\n    * [.bridge](#class-windowmanagerbridge)\r\n    * [.utils](#class-windowmanagerutils)\r\n* [Class: Window](#class-window)\r\n* [Final notes and upcoming updates](#final-notes)\r\n\r\n---\r\n\r\n## Features\r\n\r\nCreating a \"window\" in Electron is done using Electron's native [\"BrowserWindow\"](http://electron.atom.io/docs/v0.36.0/api/browser-window/) module, which is easy to use and very straight forward, until the point when you need to access/control a window from another one, or share values/events between these windows, or use a unified layout/design. That's when this modules come into picture. If you need it I guarantee you will love it :)\r\n\r\n* You can easily open, close, move, resize, clone ... etc windows. Of course all of that IS DOABLE through Electron's BrowserWindow, but our module here makes it much easier. It's a kind of wrapper for Electron's module, plus some extra functionalities and tools.\r\n* **You can access any window from within any other window**. That's because all the work is done on the \"Main\" process, and because each window is given a unique name, so that you could \"access\" it from anywhere!\r\n* **You can simply [share](#class-windowmanagershareddata) data between the created windows, and even watch for changes in this data**. Cool, right ?!\r\n* You can, very easily, **connect all of the created windows through events; you can trigger an event in window 1 and listen for it in window 2 and 3 and vice versa**. This will help you make your application parts more connected and live. [More details](#class-windowmanagerbridge)\r\n* For an offline/local multi-window application scenario YOU WILL NEED a way to make these windows share one layout/design, or else you will find yourself building a website in the 90s! This module will help you with this problem. [Here is how](#class-windowmanagerlayouts)\r\n\r\n![](http://i.imgur.com/va4oR6J.png)\r\n\r\n## Installation\r\nSimply type the following command in the terminal, inside the application folder\r\n``` \r\nnpm install --save electron-window-manager\r\n```\r\n\r\nThen, inside the application main.js *(or whatever you chosen for your application)*, require the module, like this:\r\n```\r\nvar windowManager = require('electron-window-manager');\r\n```\r\n\r\nNow, **this module can be used in both the \"Main\" and the \"Renderer\" processes of Electron**. In the Main process you can use it to create the application's first/main window, and later, in the Renderer process you can create the other windows of the application, or any other way you like.\r\n\r\n**On the Main process you can use it like this**:\r\n```\r\n\tconst electron = require('electron');\r\n    const application = electron.application;\r\n    const windowManager = require('electron-window-manager');\r\n\r\n    // When the application is ready\r\n    application.on('ready', function(){\r\n\t\twindowManager.init( ... );\r\n    \t// Open a window\r\n        windowManager.open('home', 'Welcome ...', '/home.html');\r\n    });\r\n\r\n```\r\n**And on the Renderer process** (inside the created window), you can use it like this:\r\n```\r\n<script>\r\n\tvar remote = require('remote');\r\n    var windowManager = remote.require('electron-window-manager');\r\n\r\n    // Create a new window\r\n    var win2 = windowManager.createNew('win2', 'Windows #2');\r\n    win2.loadURL('/win2.html');\r\n    win2.onReady( ... );\r\n    win2.open();\r\n</script>\r\n```\r\n\r\nPlease go ahead and check out the module code and see for yourself how it all works, there's no magic involved, but it's consistent and easy to read. Just have a look at the code and you are good to go.\r\n\r\n## How it works \r\n* **This module is basically a wrapper for Electron's `BrowserWindow`** module, so it's definitely a good start to check out Electron's [documentation for BrowserWindow](http://electron.atom.io/docs/v0.36.0/api/browser-window/).\r\n* In its core, this module **works as a holder for the `BrowserWindow` instances created, each instance is stored by a unique name**. So you could later on call any window by name. \r\n* **Each `BrowserWindow` instance is created inside the [\"Window\"](#class-window) class**, which in a way extends and adds more functionalities to it. \r\n* When creating a new window you are required to provide a basic SETUP for it, stuff like the width, height, title, url ... etc. The setup options `BrowserWindow` offers are plenty, and this module adds couple more. **If some/many of the windows share the same setup, you can simply create a [\"Setup Template\"](#class-windowmanagertemplates) and pass this template (by name) to the window in the making to apply the setup**.\r\n* After a window is created you can change its content, resize it, move it, take it to full screen, ... pretty much anything you may need, even you can execute JS code on it, from another window ... cool ha!\r\n* A development-mode is on by default, until you finish developing the application and set it off. **The development mode will make debugging  a bit easier; you will be able to reload ANY window just by pressing ``` CTRL + R```, also you will be able to toggle the development tools Chrome offers just by pressing ```CTRL + F12```**, for any window and without any pre-configuration. The developer tools could be turned on by default for a window just by passing *\"showDevTools: true\"* in the window setup, or even by calling the method *showDevTools()* on the window object.\r\n\r\n---\r\n# API\r\n\r\n## Class: WindowManager\r\nThe `windowManager` class is the interface of the module, through which you can access the created windows, and of course create new ones. Also through it you can access everything the module uses internally, like utilities and other modules used in the process.\r\n\r\n### `windowManager.windows`\r\nThis property is where the created `Window` instances are stored, each by its name\r\n\r\n### `windowManager.config`\r\nThe basic configuration of the module\r\n\r\n### `init( config )`\r\n\r\nThis method initiates the module so that you could use it. It takes one *optional* argument, which is the configuration. You only need to initiate the module once, and that's on the \"Main\" process.\r\n\r\n* **config**\r\n\t* **appBase** (string): The path to the application base, whether it's local or remote. **By default the local path to the application directory is used**.\r\n\t* **devMode** (boolean): Sets whether the development mode is on or off, it's on by default.\r\n\t* **layouts** (object): As mentioned, this module will help you use  layout(s) for the content of your windows. This option is where you can pass a list of the layout file(s), each under a specific name. Here's an example:\r\n\t```\r\n\t\twindowManager.init({\r\n\t\t\t'layouts': {\r\n\t\t\t\t'default': '/layouts/default.html',  // The \"/\" at the start will be replaced with the \"appBase\" value\r\n\t\t\t\t'secondary': '/layouts/secondary.html'\r\n\t\t\t}\r\n\t\t});\r\n\t```\r\n\tThis of course will be effective only when the app is local, or at least the target file is stored locally. [More details on the \"Layouts\" feature](#class-windowmanagerlayouts)\r\n\t\r\n\t* **defaultLayout** (string): The name of the default layout. \r\n    * **defaultSetupTemplate** (string): The name of the setup template that you want as the default for all of the application windows. \"Setup Templates\" is a way of presetting shared setup properties for the application windows. [More details](#class-windowmanagertemplates)\r\n    * **defaultWindowTitle** The default title for the windows; will be used if a window title wasn't specified, and if the setup template didn't provide a title either! Here you can simply use the name of the application.\r\n\t* **windowsTitlePrefix** (string): Each window can have its own title, this value will allow you to set a prefix for this title, for all the windows, ... maybe the application name!\r\n\t* **onLoadFailure** (function): Here you can set what happens whenever the target URL of a window isn't accessible, meaning that the loading has failed, for whatever reason. By default a small message will be be displayed instead of the page (it basically loads the *loadFailure.html* file from the module directory). Here's an example: \r\n\t```\r\n\t\twindowManager.init({\r\n\t\t\t'onLoadFailure': function(window){\r\n\t\t\t\twindow.loadURL('/404.html');\r\n\t\t\t\t// -- or ---\r\n\t\t\t\twindow.write('<h3> Cannot load the requested page! </h3>');\r\n\t\t\t}\r\n\t\t});\r\n\t```\r\n\r\n### `setDefaultSetup( setup )`\r\nThis method sets the default setup for the application windows, it basically creates a new setup template with the name \"default\", and marks it as the default. Example:\r\n```\r\n\twindowManager.setDefaultSetup({'width': 600, 'height': 450, 'position': 'right'});\r\n```\r\n**When creating a new window this setup will be used automatically, you can override this by passing FALSE as the setup template name.**\r\n\r\n### `createNew( name, title, url, setupTemplate, setup, showDevTools )`\r\nThis method, as the name suggests, creates a new window, it will create and return a new instance of the class [Window](#class-window). **All of the listed arguments up there are optional by the way**, even the url; you can omit it now and set it later. \r\n\r\n* **name** (string): The name of the new window, if omitted a serialized name will be used instead, like\r\n\"window_1\" ~> \"window_2\" ~> ...\r\n* **title** (string): The window title. If omitted the setup template 'title' property will be used, and if this property wasn't provided the `config.defaultWindowTitle` will be used instead. If all of that isn't set the document title will be used.\r\n* **url** (string): The targeted URL for the window, it could be a local file (file:// ... .html), or a URL\r\n(http:// ...). If the passed value here starts with \"/\" the value will be preceded by the \"appBase\" (which is\r\nthe path to the application base, set in the config), also you can use `{appBase}` inside the passed value and it will be replaces with the application base path.\r\n* **setupTemplate** (string) The name of setup template you want applied to this new window. \"Setup Templates\"\r\nis a way of sharing preset setup properties with more than one window.\r\n* **setup** (object|string) [optional] The new window setup. **The full options list is available [here](http://electron.atom.io/docs/v0.36.0/api/browser-window/)**.This module offers couple more options to use in the mix, but we will get to that later. BTW, as a shortcut you can pass the new window dimensions like this \"300x200\", where 300 is the width and 200 is the height!\r\n* **showDevTools** (boolean) Whether to show the developer tools offered by Chrome or not, for debugging. False\tby default.\r\n\r\nHere's an example:\r\n```\r\n\tvar homeWindow = windowManager.createNew('home', 'Welcome ...', '/pages/home.html', false, {\r\n\t\t'width': 600,\r\n\t\t'height': 450,\r\n\t\t'position': 'topLeft',\r\n\t\t'layout': 'simple',\r\n\t\t'showDevTools': true,\r\n\t\t'resizable': true\r\n\t});\r\n\r\n\thomeWindow.registerShortcut('CmdOrCtrl+N', function(window){\r\n\t\twindow.minimize();\r\n\t\twindowManager.open( ... );\r\n\r\n\t}).open();\r\n```\r\nAs mentioned, beside the the setup options `BrowserWindow` offers we offer couple more:\r\n\r\n* **layout** (string) The name of the layout you want the window's content to be displayed inside.\r\n* **position** (string|array) This setup option sets the position of the window on the screen, you can pass the x & y coordinates as an array (ex: [300, 200]), or simply pass the position name, the available positions are: *top, right, bottom, left, topRight, topLeft, bottomRight, bottomLeft*. The default position by the way is \"center\".\r\n```\r\n    var win = windowManager.createWindow(false, false, false, false, {'position': 'bottomRight'});\r\n```\r\n* **onLoadFailure** (function) This callback will be triggered whenever the URL loading fails.\r\n```\r\n    var win = windowManager.open(false, false, false, false, {\r\n        'onLoadFailure': function(window){\r\n            window.close();\r\n        }\r\n    })\r\n```\r\nIf you don't set this a default callback will handle it, by showing a global \"Not available\" message page, this global callback can be set in windowManager.init()\r\n\r\n* **showDevTools** (boolean) Whether to show the dev tools or not\r\n\r\n\r\n### `open( name, title, url, setupTemplate, setup, showDevTools )`\r\nThis is the same as the `createNew` method, except that it opens the window directly\r\n\r\n### `importList( file )`\r\nUsing this method you can create more than one window instance, with the setup information retrieved from a JSON file. You will use it like this:\r\n```\r\n\t// windows.json\r\n\t{\r\n\t\t\"home\": { \"title\": \"Home\", \"url\": \"http:// ...\", \"setup\": { ... } },\r\n\t\t\"about\": { \"title\": \"About\", ... }\r\n\t}\r\n\r\n\t// Import the window list\r\n\twindowManager.importList('windows.json');\r\n\r\n\t// Open a window, by name\r\n\twindowManager.get('home').open();\r\n```\r\n\r\n### `clone( name )`\r\nCreates a clone of the specified window and returns the `Window` class instance\r\n\r\n### `get( name )`\r\nReturns the `window` instance of the specified window\r\n```\r\n\tvar win = windowManager.get('home');\r\n\twin.resize(300, 200).restore();\r\n```\r\n\r\n### `getCurrent()`\r\nReturns the `Window` instance of the currently-under-focus window\r\n```\r\n\twindowManager.getCurrent().close();\r\n```\r\n\r\n### `close( name )`\r\nCloses a window, by its name\r\n\r\n### `closeCurrent()`\r\nCloses the current window\r\n\r\n### `destroy( name )`\r\nDestroys the window instance, by its name\r\n\r\n### `closeAll()`\r\nCloses all the windows created by this module\r\n\r\n### `closeAllExcept( name )`\r\nCloses all the window, except for one, the one you pass its name\r\n\r\n### `minimize( name )`\r\nMinimizes a window, by its name\r\n```\r\n\twindowManager.minimize('help');\r\n```\r\n\r\n### `restore( name )`\r\nRestores a minimized window, by name\r\n\r\n### `devModeChoice( whenDevMode, whenNotDevMode )`\r\nThis method simply takes two values, the first is the one that goes when the development mode is on and the other is when it's off, and according to whether it's on or off, the corresponding value will be returned\r\n```\r\n\tvar api = windowManager.devModeChoice({'key': ... }, {'key': ...});\r\n```\r\n\r\n## Class: windowManager.templates\r\nWhen creating a new window you will need to provide a basic setup; things like the width, height and of course the window URL (the targeted content). The available setup options are plenty, and in most cases you will find yourself repeating it with each window you create. **The \"Setup Templates\" feature will help you make presets of the setup properties you use and name them, and later when creating a new window you will just pass the template name and the associated setup will be applied.**\r\n```\r\n    windowManager.templates.set('samll', {\r\n        'width': 600,\r\n        'height': 350,\r\n        'resizable': true,\r\n        'layout': 'classy',\r\n        'showDevTools': true,\r\n        'title': 'App name, for small windows!', // Yeah, even the window title!\r\n        'onLoadFailure': function(){ ... }\r\n    });\r\n    \r\n    windowManager.open(false, false, 'welcom.html', 'small');\r\n    windowManager.open(false, false, 'byebye.html', 'small');\r\n```\r\nYou of course can set a default template for all the windows to inherit\r\n```\r\n    windowManager.init({\r\n        'defaultSetupTemplate': 'small'\r\n    });\r\n    \r\n    windowManager.templates.set('small', { ... });\r\n```\r\nYou can override this option for a specific window by passing FALSE as the setupTemplate name.\r\n```\r\n    windowManager.open('home', 'Welcome', '/pages/welcome.html', FALSE);\r\n```\r\n**If you wont ignore the default setup template but need to omit the argument just pass null!**\r\n```\r\n    windowManager.open('home', 'Welcome', '/pages/welcome.html', null, { ... });\r\n```\r\n\r\n### `windowManager.templates.set( name, setup )`\r\nUse this method to create a new template, you provide a name and the preferred setup, and later you can use that\r\nname when you are creating a new window, to apply the specified setup.\r\n```\r\n\twindowManager.templates.set('big', {\r\n\t\t'width': 1000,\r\n\t\t'height': 600\r\n\t});\r\n```\r\n\r\n### `windowManager.templates.get( name )`\r\nFetches a setup template by name\r\n\r\n### `windowManager.templates.modify ( name, setup )`\r\nUse this method to modify the setup of a specific template, to override one or more of its properties\r\n```\r\n    windowManager.templates.modify('big', {'height': 650});\r\n```\r\n\r\n### `windowManager.templates.getProperty ( name, property )`\r\nReturns the value of a specific property of the given template\r\n```\r\n\twindowManager.templates.getProperty('big', 'width');\r\n```\r\n\r\n## Class: windowManager.layouts\r\nA nice feature this module offer is \"Layouts\". Through this feature you can set a layout/theme/design for your application. If you are working on a multi-window app this feature will be very handy.\r\nThis feature doesn't offer much right now, but I will put more focus on in the next releases. **Here's how it works: you create a layout file, with all the assets and code you want, when you create a new window the content (HTML) of this window will be embeded/included within the layout code.** Thus you won't duplicate your code with each window; you will just include the window content withing a ready layout.\r\n```\r\n    // layout.html\r\n    <!doctype html>\r\n    <html lang=\"en\">\r\n    <head>\r\n        ....\r\n    </head>\r\n    <body>\r\n        \r\n        {{content}} <!--This will be replaced with the window content-->\r\n        \r\n        <script>\r\n            ...\r\n        </script>\r\n    </body>\r\n    </html>\r\n    \r\n    // welcome.html (the window content)\r\n    <h3>Welcome ...</h3>\r\n```\r\nOf course you can create more than one layout, and when creating a new window you chose which layout you want the window content included in. And of course you can set a default layout for all of the application windows.\r\n```\r\n    var win = windowManager.createNew('home', 'Welcome ... ', '/pages/welcome.html', false, {'layout': 'simple'});\r\n    // or \r\n    win.setLayout('simple');\r\n```\r\nTo set a default layout for the whole application you simple pass its name in the initiation config\r\n```\r\n    windowManager.init({\r\n        'defaultLayout': 'simple'\r\n    })\r\n```\r\nTo override this option for a specific window you will need to pass FALSE for the property \"layout\" when creating the window\r\n\r\n### `windowManager.layouts.add( name, path )`\r\nAdds a new layout, you need to provide the path to the layout file, and a name that represents this layout, so\r\nthat you could use it when creating a new window.\r\n```\r\n\twindowManager.layouts.add('default', '/layouts/default.html'); // The \"/\" at the beginning = {appBase}\r\n```\r\n### `windowManager.layouts.get( name )`\r\nFetches a layout by name\r\n\r\n## class: windowManager.sharedData\r\nThis class offers a simple way of sharing data between windows, you can simply set a value on window #1 and get it on window #2\r\n\r\n### `windowManager.sharedData.data` \r\nIs where the data itself is stored\r\n\r\n### `windowManager.sharedData.set( key, value )`\r\nStores a value by a key name\r\n```\r\n\twindowManager.sharedData.set('user', {'name': ' ... ', 'email': ' ... '});\r\n```\r\n\r\n### `windowManager.sharedData.fetch( key )`\r\nFetches a value, by key name\r\n```\r\n\twindowManager.sharedData.fetch('user');\r\n```\r\n\r\n### `windowManager.sharedData.watch( prop, callback )`\r\nYou can use this method to watch for changes in the saved data\r\n* **prop** Is the key you want to watch\r\n* **callback** Is the callback that will be triggered whenever the value of this property gets changed\r\n\r\n```\r\n\twindowManager.sharedData.watch('user', function(prop, action, newValue, oldValue){\r\n\t\tconsole.log('The property: ', prop, ' was:', action, ' to: ', newValue, ' from: ', oldValue);\r\n\t});\r\n```\r\n\r\nThis feature is available using [WatchJS](https://github.com/melanke/Watch.JS), please visit the module docs for further details. Also, you can access WatchJS itself in case you needed the whole API like this:\r\n```\r\n\twindowManager.sharedData.watcher; // The WatchJS module\r\n\t\r\n\tvar watcher = windowManager.sharedData.watcher;\r\n\twatcher.unwatch( ... );\r\n```\r\n\r\n\r\n## class: windowManager.bridge\r\n> This is a simple feature to help you make your app more alive and connected windows-wise. You will be able to emit and listen to events inside the created windows.\r\n\r\nHere's an example:\r\n```\r\n\t// On window \"home\"\r\n\twindowManager.bridge.on('new_chat_message', function(event){\r\n\t\t...\r\n\t});\r\n\t\r\n\t// On window \"chats\"\r\n\twindowManager.bridge.emit('new_chat_message', {'message': ' ... '});\r\n\t\r\n```\r\n\r\n### `windowManager.bridge.emit( event, data, target )`\r\nThis method emits an event to whatever page listening for it\r\n* **event** The name of the event that will be emitted\r\n* **data** [optional] Any extra data you need to broadcast along with the event\r\n* **target** [optional] The name of the targeted. In case you are targeting a specific window.\r\n\r\n### `windowManager.bridge.on( event, callback )`\r\nThis method adds a listener for a specific `event`, and whenever this event is triggered the `callback` will be called.\r\n* **event** The name of the event the window will be watching for\r\n* **callback** The callback to call when the event is emitted. This call back will be passed 1 parameters with the following properties:\r\n\t* **event** The event name\r\n\t* **target** The name of the targeted window, if specified\r\n\t* **emittedBy** The name of the window that emitted the event\r\n\r\nThis feature is basically a wrapper for NodeJs native EventEmitter class, which is used heavily almost every where inside Electron itself. Check it the [docs](https://nodejs.org/api/events.html#events_class_eventemitter) for extra knowledge about the subject. You also can access the EventEmitter used by this module simply by calling `windowManager.eventEmitter`\r\n\r\n```\r\n\twindowManager.eventEmitter.addListener( ... );\r\n```\r\n## Class: windowManager.utils\r\nThis object holds a couple of utility method, for module internal use, and for you if you need it. I am probably\r\nwill be adding more methods to this class later.\r\n\r\n### `windowManager.utils.getAppLocalPath()`\r\nReturns the path to the application directory\r\n\r\n### `windowManager.utils.readyURL( url )`\r\nIt readies the given URL for use with in the module, basically it replaces the \"{appBase}\" with the path to the\r\napplication directory.\r\n\r\n### `windowManager.utils.resolvePosition( position, setup )`\r\nThis method takes a position by name and returns the corresponding x and y coordinates, the accepted values are:\r\n\"top\", \"bottom\", \"right\", \"left\", \"topRight\", \"topLeft\", \"bottomRight\", \"bottomLeft\" and \"center\". The second\r\nargument is the window setup object. You probably wont be needing this method, put here it's, just in case.\r\n\r\n---\r\n\r\n# Class: Window\r\nThe `Window` class is basically the whole thing, [windowManager](#class-windowmanager) is merely an access point for its instances. Whenever you use `windowManager.createNew( ... )` or `windowManager.open( ... )` you are creating a new instance of `Window`.\r\n```\r\n    var window = new Window( name, title, url, setupTemplate, setup, showDevTools );\r\n```\r\n**But don't try to use the above code, `Window` isn't available in your app scope**, use `windowManager.createNew/open` instead, and as you can see the arguments are the same in the 3 cases, **check out [windowManager.createNew](#createnew-name-title-url-setuptemplate-setup-showdevtools-) for more info on the arguments**.\r\n\r\n### `Window.name` \r\nStores the widnow name\r\n\r\n### `Window.setup` \r\nStores the window setup object\r\n\r\n### `Window.object`\r\nStores the `BrowserWindow` instance created\r\n\r\n### `open( url )`\r\nOpens/shows the created window.\r\n```\r\n    var win1 = windowManager.createNew(false, false, 'win1.html');\r\n    win1.open();\r\n    \r\n    // or \r\n    var win2 = windowManager.createNew();\r\n    win2.open('win2.html');\r\n\r\n```\r\n\r\n### `focus()`\r\nMakes the window under focus\r\n\r\n### `useLayout( name )`\r\nSets the layout to use in the window, by name\r\n```\r\n    var window = window.createNew( ... );\r\n    window.useLayout('classy');\r\n    window.open();\r\n```\r\n\r\n### `setURL( url )`\r\nSets the target URL for the window, to open a URL *after* the window is open use `loadURL()`\r\n\r\n### `applySetupTemplate( name )`\r\nSets the setup template to use, by name.\r\n```\r\n    var window = window.createNew( ... );\r\n    window.applySetupTemplate('big');\r\n    window.open();\r\n```\r\n\r\n### `loadURL( url, options )` \r\nSets the content of the new window; the url it will open. Same as with [BrowserWindow](http://electron.atom.io/docs/v0.36.0/api/browser-window/#win-loadurl-url-options) you can use both local and remote targets. \r\n```\r\n    var win = windowManager.createNew();\r\n    win.loadURL('file://' + __dirname + 'index.html');\r\n    // or \r\n    win.loadURL('http://google.com');\r\n```\r\nThe same way you would open a url using any browser. Now, to make things easier you can set the base path to the application in the config (while initiating the module) and use this path in any URL-value you path to the module, `appBase`, or by simply starting the value with \"/\".\r\n```\r\n    win.loadURL('/pages/index.html');\r\n    // or \r\n    win.loadURL(' ... {appBase} ... ');\r\n```\r\n\r\n### `html( code, options )`\r\nIt simply sets the HTML code of the window, instead of loading a url\r\n```\r\n    win.html('<h3> Electron is AWESOME </h3>');\r\n```\r\n\r\n### `down()`\r\nIt simply takes the page down! It will trigger the `onLoadFailure` callback, which by default will force display a \"Not available\" message page. This method is called whenever the target url of the window isn't available, instead of displaying a blank page.\r\n\r\n### `content()`\r\nReturns `BrowserWindow`'s [webContents](http://electron.atom.io/docs/v0.36.0/api/web-contents/) object for the window.\r\n```\r\n    win.content().on('did-fail-load', function(){ ... });\r\n    win.content().downloadURL( ... )\r\n    win.content().reload()\r\n    win.content().print()\r\n```\r\n\r\n### `reload( ignoreCache )`\r\nReloads the URL of the window, if TRUE is passed the page will be reloaded with the cache ignored.\r\n```\r\n    win.reload(); // With cache\r\n    win.reload(true); // Without cache\r\n```\r\n\r\n### `currentURL()`\r\nReturns the URL open inside the window\r\n\r\n### `onReady( withTheDomReady, callback )`\r\nRegisters a callback that triggers when the page is ready. If you pass TRUE for the `withTheDomReady` argument the callback will trigger only when the DOM is ready, and not before.\r\n```\r\n    win.onReady(true, function(window){\r\n        window.resize(600);\r\n    });\r\n```\r\n\r\n### `execute( code )`\r\nExecutes JavaScript code on the window content\r\n```\r\n    win.execute(' alert(\" Hi! \") ');\r\n```\r\n\r\n### `goBack()`\r\nGoes back to the previous page, Electron is a browser after all!\r\n\r\n\r\n### `close()`\r\nCloses the window\r\n\r\n### `minimize()`\r\nMinimizes the window\r\n\r\n### `restore()`\r\nRestores the window back in focus\r\n\r\n### `toFullScreen()`\r\nTakes the window to fullscreen\r\n\r\n### `toggleDevTools()`\r\nToggles the developer tools. **By default, and when the `devMode` is on you can open the developer tools by pressing `CTRL + F12` on any window.**\r\n\r\n### `registerShortcut( accelerator, callback )`\r\nRegisters a keyboard shortcut on the window\r\n```\r\n    win.registerShortcut('CTRL+N', function(){\r\n        windowManager.open( ... );\r\n    });\r\n\r\n```\r\nThis feature is available thanks to the  [electron-loaclshortcut](https://github.com/parro-it/electron-localshortcut) module. Here's more details on the [shortcuts codes](https://github.com/atom/electron/blob/master/docs/api/accelerator.md). The module itself can be access through `windowManager.shortcuts` in case you wanted to use more of it, to globally-register a new shortcut or something.\r\n```\r\n    windowManager.shortcuts.unregisterAll();\r\n```\r\n\r\n### `move( x, y )`\r\nMoves the window to a specific x (and/or) y coordinates. You can also provide a position \"name\" and it will be resolved to the correct position according to the screen size and the window dimensions. The available position names are *top, right, bottom, left + topRight, topLeft, bottomRight, bottomLeft* \r\n```\r\n    win.move(300, 200);\r\n    win.move('topLeft');\r\n```\r\n\r\n### `resize( width, height )`\r\nResizes the window to a specific width and/or height\r\n```\r\n    win.resize(1000); // Only set the width\r\n    win.resize(800, 400);\r\n```\r\n\r\n---\r\n## Final notes\r\n* You may find this module a bit redundant, but if you use Electron for complex multi-window projects you will probably need it.\r\n* I actually spent more time on writing this documentation than I spent on writing the module itself, so **PLEASE if you have any comments or suggestions of any kind write me or open an issue**.\r\n* **The development of this module WILL be continued**, so feel safe to use it and know I got your back ;)\r\n* **The next releases** will ...\r\n    * Put more focus on the **Layouts** feature, I will probably use [Handlebars](http://handlebarsjs.com/) to offer templating capabilities.\r\n    * Offer more debugging tools and feature.\r\n    * Better documentation and code examples\r\n\r\n\r\nAnd yeah, THANKS GITHUB FOR ELECTRON, IT'S A DREAM CAME TRUE, IT'S AWESOME.\r\n\r\n---\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2015 Ahmed Zain <tamkeenlms@gmail.com>\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/azain/electron-window-manager/issues"
  },
  "_id": "electron-window-manager@1.0.1",
  "_from": "electron-window-manager@"
}
